.. _dev:

Developer's Guide
====================

Notes to add:  C++ class / function naming conventions, uncrustify, pep8 linter, etc.

TOAST aims to follow best practices whenever reasonably possible.  If you submit a pull request to contribute C++ code, try to match the existing coding style (indents are 4 spaces, not tabs, curly brace placement, spacing, etc).  If you are contributing python code follow `PEP-8 <https://www.python.org/dev/peps/pep-0008/>`_.  When documenting python classes and methods, we use `google-style docstrings <http://google.github.io/styleguide/pyguide.html?showone=Comments#Comments>`_.  The C++ code in TOAST uses the google test framework for unit tests.  Python code uses the standard built in unittest classes.  When contributing new code, please add unit tests as well.  Even if we don't have perfect test coverage, that should be our goal.  When actively developing the codebase, you can run the C++ unit tests without installation by doing::

    %> make check

In order to run the python unit tests, you must first do a "make install".


Python Code
-------------------

We aim to follow PEP8 style guidelines whenever possible.  There are some reasonable exceptions to this.  In particular, import statements might not always be placed at the top of the code if:

- The import is an optional feature that has large performance impacts and which is only used infrequently.  For example matplotlib, astropy, etc.

- Some initialization code is needed prior to the import statement.  For example, setting the matplotlib backend.

Other style choices:

- Double quotes for strings unless the string contains double quotes, resulting in excessive backslash escaping.


Compiled Code
-------------------

Class names follow python CamelCase convention
Function names follow python_underscore_convention

Formatting set by uncrustify.

All code that is exposed through pybind11 in a single toast namespace.  Nested namespaces may be used for code that is internal to the C++ code.

The "using" statement can be used for aliasing a specific class or type::

    using ShapeContainer = py::detail::any_container<ssize_t>;

But should **not** be used to import an entire namespace::

    using std;

Header files included with "#include" should use angle brackets ("<>") for the header file name.  If this fails for some reason then that indicates a problem with the build system and its header file search paths.  Using double quotes for #include statements is OK when including raw source files in the same directory (for example, when including raw *.cpp contents generated by external scripts).

When include C standard header files in C++, use the form::

    #include <cstdio>

Rather than::

    #include <stdio.h>


Pointer / reference declaration.  This allows reading from right to left as "a pointer to a constant double" or "a reference to a constant double".

    double const * data
    double const & data

Not:

    const double * data
    const double & data

When indexing the size of an STL container, the index variable should be either of the size type declared in the container class or size_t.

When describing time domain sample indices or intervals, we using int64_t everywhere for consistency.  This allows passing, e.g. "-1" to communicate unspecified intervals or sample indices.

Single line conditional statements:

    if (x > 0) y = x;

Are permitted if they fit onto a single line.  Otherwise, insert braces.

Internal toast source files should not include the main "toast.hpp".  Instead
they should include the specific headers they need.  For example::

    #include <toast/sys_utils.hpp>
    #include <toast/math_lapack.hpp>
    #include <toast/math_qarray.hpp>


If attempting to vectorize code with OpenMP simd constructs, be sure to check that any data array used in the simd region are aligned (see toast::is_aligned).  Otherwise this can result in silent data corruption.

Documentation:  sphinx is used.  All python code should have docstrings.  All C++ code exposed through pybind11 should also have docstrings defined in the bindings.  C++ code that is not exposed to python is considered is internal, expert-level code does not require formal documentation.  However, such code should have sufficient comments to describe the algorithm and design choices.



NOTES for OS X
=========================

homebrew:

brew install fftw cfitsio suite-sparse zlib cmake boost-python3
-->  this brings in openmpi as well

Need to install hdf5 and h5py manually, since homebrew package built with gcc, not clang.


macports:

sudo port install mpich-devel-gcc9
sudo port select --set mpi mpich-devel-gcc9-fortran

https://trac.macports.org/ticket/58333#comment:8

sudo port install cfitsio fftw suitesparse py37-h5py py37-virtualenv m4 libtool autoconf automake cmake zlib

sudo port select --set cython cython37
sudo port select --set python3 python37
sudo port select --set virtualenv virtualenv37

sudo port install boost +python37
